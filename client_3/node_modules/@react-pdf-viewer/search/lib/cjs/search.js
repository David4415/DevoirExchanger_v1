'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var core = require('@react-pdf-viewer/core');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

var NextIcon = function () {
    return (React__namespace.createElement(core.Icon, { size: 16 },
        React__namespace.createElement("path", { d: "M0.541,5.627L11.666,18.2c0.183,0.207,0.499,0.226,0.706,0.043c0.015-0.014,0.03-0.028,0.043-0.043\n                L23.541,5.627" })));
};

var PreviousIcon = function () {
    return (React__namespace.createElement(core.Icon, { size: 16 },
        React__namespace.createElement("path", { d: "M23.535,18.373L12.409,5.8c-0.183-0.207-0.499-0.226-0.706-0.043C11.688,5.77,11.674,5.785,11.66,5.8\n                L0.535,18.373" })));
};

var SearchIcon = function () {
    return (React__namespace.createElement(core.Icon, { size: 16 },
        React__namespace.createElement("path", { d: "M10.5,0.5c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.5,10.5,0.5z\n                M23.5,23.5\n                l-5.929-5.929" })));
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || from);
}

var EMPTY_KEYWORD_REGEXP = new RegExp(' ');

var normalizeFlagKeyword = function (flagKeyword) {
    var source = flagKeyword.wholeWords ? " " + flagKeyword.keyword + " " : flagKeyword.keyword;
    var flags = flagKeyword.matchCase ? 'g' : 'gi';
    return new RegExp(source, flags);
};
var normalizeSingleKeyword = function (keyword, matchCase, wholeWords) {
    if (keyword instanceof RegExp) {
        return keyword;
    }
    if (typeof keyword === 'string') {
        return keyword === ''
            ? EMPTY_KEYWORD_REGEXP
            : normalizeFlagKeyword({
                keyword: keyword,
                matchCase: matchCase || false,
                wholeWords: wholeWords || false,
            });
    }
    if (typeof matchCase !== 'undefined') {
        keyword.matchCase = matchCase;
    }
    if (typeof wholeWords !== 'undefined') {
        keyword.wholeWords = wholeWords;
    }
    return normalizeFlagKeyword(keyword);
};

var useDocument = function (store) {
    var currentDocRef = React__namespace.useRef(store.get('doc'));
    var handleDocumentChanged = function (doc) {
        currentDocRef.current = doc;
    };
    React__namespace.useEffect(function () {
        store.subscribe('doc', handleDocumentChanged);
        return function () {
            store.unsubscribe('doc', handleDocumentChanged);
        };
    }, []);
    return { currentDoc: currentDocRef.current };
};

var useSearch = function (store) {
    var currentDoc = useDocument(store).currentDoc;
    var _a = React__namespace.useState([]), keywords = _a[0], setKeywords = _a[1];
    var _b = React__namespace.useState([]), found = _b[0], setFound = _b[1];
    var _c = React__namespace.useState(0), currentMatch = _c[0], setCurrentMatch = _c[1];
    var _d = React__namespace.useState(false), matchCase = _d[0], setMatchCase = _d[1];
    var textContents = React__namespace.useRef([]);
    var _e = React__namespace.useState(false), wholeWords = _e[0], setWholeWords = _e[1];
    var changeMatchCase = function (isChecked) {
        setMatchCase(isChecked);
        if (keywords.length > 0) {
            searchFor(keywords, isChecked, wholeWords);
        }
    };
    var changeWholeWords = function (isChecked) {
        setWholeWords(isChecked);
        if (keywords.length > 0) {
            searchFor(keywords, matchCase, isChecked);
        }
    };
    var jumpToPreviousMatch = function () {
        if (keywords.length === 0 || found.length === 0) {
            return;
        }
        var prev = currentMatch - 1;
        var updated = prev > 0 ? prev : found.length;
        setCurrentMatch(updated);
        jumpToMatch(found[updated - 1]);
    };
    var jumpToNextMatch = function () {
        if (keywords.length === 0 || found.length === 0) {
            return;
        }
        var next = currentMatch + 1;
        var updated = next <= found.length ? next : 1;
        setCurrentMatch(updated);
        jumpToMatch(found[updated - 1]);
    };
    var clearKeyword = function () {
        if (keywords.length === 0) {
            return;
        }
        store.update('keyword', [EMPTY_KEYWORD_REGEXP]);
        setKeyword('');
        setCurrentMatch(0);
        setFound([]);
        setMatchCase(false);
        setWholeWords(false);
    };
    var search = function () { return searchFor(keywords, matchCase, wholeWords); };
    var setKeyword = function (keyword) { return setKeywords(keyword === '' ? [] : [keyword]); };
    var getTextContents = function () {
        if (!currentDoc) {
            return Promise.resolve([]);
        }
        var promises = Array(currentDoc.numPages)
            .fill(0)
            .map(function (_, pageIndex) {
            return currentDoc
                .getPage(pageIndex + 1)
                .then(function (page) {
                return page.getTextContent();
            })
                .then(function (content) {
                var pageContent = content.items.map(function (item) { return item.str || ''; }).join('');
                return Promise.resolve({
                    pageContent: pageContent,
                    pageIndex: pageIndex,
                });
            });
        });
        return Promise.all(promises).then(function (data) {
            data.sort(function (a, b) { return a.pageIndex - b.pageIndex; });
            return Promise.resolve(data.map(function (item) { return item.pageContent; }));
        });
    };
    var jumpToMatch = function (match) {
        var jumpToPage = store.get('jumpToPage');
        if (jumpToPage) {
            jumpToPage(match.pageIndex);
        }
        store.update('match', match);
    };
    var getKeywordSource = function (keyword) {
        if (keyword instanceof RegExp) {
            return keyword.source;
        }
        if (typeof keyword === 'string') {
            return keyword;
        }
        return keyword.keyword;
    };
    var searchFor = function (keywordParam, matchCaseParam, wholeWordsParam) {
        var keywords = keywordParam.map(function (k) { return normalizeSingleKeyword(k, matchCaseParam, wholeWordsParam); });
        store.update('keyword', keywords);
        setCurrentMatch(0);
        setFound([]);
        var promise = textContents.current.length === 0
            ? getTextContents().then(function (response) {
                textContents.current = response;
                return Promise.resolve(response);
            })
            : Promise.resolve(textContents.current);
        promise.then(function (response) {
            var arr = [];
            response.forEach(function (item, pageIndex) {
                var numMatches = keywords.map(function (k) { return (item.match(k) || []).length; }).reduce(function (a, b) { return a + b; }, 0);
                for (var matchIndex = 0; matchIndex < numMatches; matchIndex++) {
                    arr.push({
                        matchIndex: matchIndex,
                        pageIndex: pageIndex,
                    });
                }
            });
            setFound(arr);
            if (arr.length > 0) {
                setCurrentMatch(1);
                jumpToMatch(arr[0]);
            }
        });
    };
    React__namespace.useEffect(function () {
        textContents.current = [];
    }, [currentDoc]);
    return {
        clearKeyword: clearKeyword,
        changeMatchCase: changeMatchCase,
        changeWholeWords: changeWholeWords,
        currentMatch: currentMatch,
        jumpToNextMatch: jumpToNextMatch,
        jumpToPreviousMatch: jumpToPreviousMatch,
        keywords: keywords,
        matchCase: matchCase,
        numberOfMatches: found.length,
        wholeWords: wholeWords,
        search: search,
        searchFor: searchFor,
        setKeywords: setKeywords,
        keyword: keywords.length === 0 ? '' : getKeywordSource(keywords[0]),
        setKeyword: setKeyword,
    };
};

var Inner = function (_a) {
    var children = _a.children, store = _a.store;
    var result = useSearch(store);
    return children(__assign({}, result));
};
var Search = function (_a) {
    var children = _a.children, store = _a.store;
    var currentDoc = useDocument(store).currentDoc;
    return currentDoc ? React__namespace.createElement(Inner, { store: store }, children) : React__namespace.createElement(React__namespace.Fragment, null);
};

var PORTAL_OFFSET$1 = { left: 0, top: 8 };
var SearchPopover = function (_a) {
    var store = _a.store, onToggle = _a.onToggle;
    var l10n = React__namespace.useContext(core.LocalizationContext);
    var _b = useSearch(store), clearKeyword = _b.clearKeyword, changeMatchCase = _b.changeMatchCase, changeWholeWords = _b.changeWholeWords, currentMatch = _b.currentMatch, jumpToNextMatch = _b.jumpToNextMatch, jumpToPreviousMatch = _b.jumpToPreviousMatch, keyword = _b.keyword, matchCase = _b.matchCase, numberOfMatches = _b.numberOfMatches, wholeWords = _b.wholeWords, search = _b.search, setKeyword = _b.setKeyword;
    var onKeydownSearch = function (e) {
        if (e.keyCode !== 13 || !keyword) {
            return;
        }
        search();
    };
    var onChangeMatchCase = function (e) {
        changeMatchCase(e.target.checked);
    };
    var onChangeWholeWords = function (e) {
        changeWholeWords(e.target.checked);
    };
    var onClose = function () {
        onToggle();
        clearKeyword();
    };
    return (React__namespace.createElement("div", { className: "rpv-search__popover" },
        React__namespace.createElement("div", { className: "rpv-search__popover-input-counter" },
            React__namespace.createElement(core.TextBox, { placeholder: (l10n && l10n.search ? l10n.search.enterToSearch : 'Enter to search'), type: "text", value: keyword, onChange: setKeyword, onKeyDown: onKeydownSearch }),
            React__namespace.createElement("div", { className: "rpv-search__popover-counter" },
                currentMatch,
                "/",
                numberOfMatches)),
        React__namespace.createElement("label", { className: "rpv-search__popover-label" },
            React__namespace.createElement("input", { className: "rpv-search__popover-label-checkbox", checked: matchCase, type: "checkbox", onChange: onChangeMatchCase }),
            ' ',
            l10n && l10n.search ? l10n.search.matchCase : 'Match case'),
        React__namespace.createElement("label", { className: "rpv-search__popover-label" },
            React__namespace.createElement("input", { className: "rpv-search__popover-label-checkbox", checked: wholeWords, type: "checkbox", onChange: onChangeWholeWords }),
            ' ',
            l10n && l10n.search ? l10n.search.wholeWords : 'Whole words'),
        React__namespace.createElement("div", { className: "rpv-search__popover-footer" },
            React__namespace.createElement("div", { className: "rpv-search__popover-footer-item" },
                React__namespace.createElement(core.Tooltip, { position: core.Position.BottomCenter, target: React__namespace.createElement(core.MinimalButton, { onClick: jumpToPreviousMatch },
                        React__namespace.createElement(PreviousIcon, null)), content: function () { return (l10n && l10n.search ? l10n.search.previousMatch : 'Previous match'); }, offset: PORTAL_OFFSET$1 })),
            React__namespace.createElement("div", { className: "rpv-search__popover-footer-item" },
                React__namespace.createElement(core.Tooltip, { position: core.Position.BottomCenter, target: React__namespace.createElement(core.MinimalButton, { onClick: jumpToNextMatch },
                        React__namespace.createElement(NextIcon, null)), content: function () { return (l10n && l10n.search ? l10n.search.nextMatch : 'Next match'); }, offset: PORTAL_OFFSET$1 })),
            React__namespace.createElement("div", { className: "rpv-search__popover-footer-button" },
                React__namespace.createElement(core.Button, { onClick: onClose }, l10n && l10n.search ? l10n.search.close : 'Close')))));
};

var ShowSearchPopoverDecorator = function (_a) {
    var children = _a.children, onClick = _a.onClick;
    var l10n = React__namespace.useContext(core.LocalizationContext);
    var label = (l10n && l10n.search ? l10n.search.search : 'Search');
    var icon = React__namespace.createElement(SearchIcon, null);
    return children({ icon: icon, label: label, onClick: onClick });
};

var TOOLTIP_OFFSET = { left: 0, top: 8 };
var ShowSearchPopoverButton = function (_a) {
    var onClick = _a.onClick;
    return (React__namespace.createElement(ShowSearchPopoverDecorator, { onClick: onClick }, function (p) { return (React__namespace.createElement(core.Tooltip, { position: core.Position.BottomCenter, target: React__namespace.createElement(core.MinimalButton, { onClick: onClick }, p.icon), content: function () { return p.label; }, offset: TOOLTIP_OFFSET })); }));
};

var PORTAL_OFFSET = { left: 0, top: 8 };
var ShowSearchPopover = function (_a) {
    var children = _a.children, store = _a.store;
    var currentDoc = useDocument(store).currentDoc;
    var defaultChildren = function (props) { return React__namespace.createElement(ShowSearchPopoverButton, __assign({}, props)); };
    var render = children || defaultChildren;
    return currentDoc ? (React__namespace.createElement(core.Popover, { position: core.Position.BottomLeft, target: function (toggle) {
            return render({
                onClick: toggle,
            });
        }, content: function (toggle) { return React__namespace.createElement(SearchPopover, { store: store, onToggle: toggle }); }, offset: PORTAL_OFFSET, closeOnClickOutside: false, closeOnEscape: true })) : (React__namespace.createElement(React__namespace.Fragment, null));
};

var calculateOffset = function (children, parent) {
    var top = children.offsetTop;
    var left = children.offsetLeft;
    var p = children.parentElement;
    while (p && p !== parent) {
        top += p.offsetTop;
        left += p.offsetLeft;
        p = p.parentElement;
    }
    return {
        left: left,
        top: top,
    };
};

var removeNode = function (ele) {
    var parent = ele.parentNode;
    if (parent) {
        parent.removeChild(ele);
    }
};
var replaceNode = function (replacementNode, node) {
    removeNode(replacementNode);
    var parent = node.parentNode;
    if (parent) {
        parent.insertBefore(replacementNode, node);
    }
    removeNode(node);
};
var unwrap = function (ele) {
    var parent = ele.parentNode;
    if (!parent) {
        return;
    }
    var range = document.createRange();
    range.selectNodeContents(ele);
    replaceNode(range.extractContents(), ele);
    parent.normalize();
};

var Tracker = function (_a) {
    var pageIndex = _a.pageIndex, store = _a.store, onHighlightKeyword = _a.onHighlightKeyword;
    var _b = React__namespace.useState({
        matchIndex: -1,
        pageIndex: -1,
    }), match = _b[0], setMatch = _b[1];
    var _c = React__namespace.useState([EMPTY_KEYWORD_REGEXP]), keywordRegexp = _c[0], setKeywordRegexp = _c[1];
    var _d = React__namespace.useState({
        pageIndex: pageIndex,
        scale: 1,
        status: core.LayerRenderStatus.PreRender,
    }), renderStatus = _d[0], setRenderStatus = _d[1];
    var currentMatchRef = React__namespace.useRef(null);
    var characterIndexesRef = React__namespace.useRef([]);
    var unhighlightAll = function (containerEle) {
        var highlightNodes = containerEle.querySelectorAll('span.rpv-search__highlight');
        var total = highlightNodes.length;
        for (var i = 0; i < total; i++) {
            highlightNodes[i].parentElement.removeChild(highlightNodes[i]);
        }
    };
    var highlight = function (keyword, containerEle, span, charIndexSpan) {
        var range = document.createRange();
        var firstChild = span.firstChild;
        if (!firstChild) {
            return;
        }
        var startOffset = charIndexSpan[0].charIndexInSpan;
        var endOffset = charIndexSpan.length === 1 ? startOffset : charIndexSpan[charIndexSpan.length - 1].charIndexInSpan;
        range.setStart(firstChild, startOffset);
        range.setEnd(firstChild, endOffset + 1);
        var wrapper = document.createElement('span');
        range.surroundContents(wrapper);
        var wrapperRect = wrapper.getBoundingClientRect();
        var containerRect = containerEle.getBoundingClientRect();
        var highlightEle = document.createElement('span');
        containerEle.appendChild(highlightEle);
        highlightEle.style.left = (100 * (wrapperRect.left - containerRect.left)) / containerRect.width + "%";
        highlightEle.style.top = (100 * (wrapperRect.top - containerRect.top)) / containerRect.height + "%";
        highlightEle.style.width = (100 * wrapperRect.width) / containerRect.width + "%";
        highlightEle.style.height = (100 * wrapperRect.height) / containerRect.height + "%";
        highlightEle.classList.add('rpv-search__highlight');
        highlightEle.setAttribute('title', keyword.source.trim());
        unwrap(wrapper);
        if (onHighlightKeyword) {
            onHighlightKeyword({
                highlightEle: highlightEle,
                keyword: keyword,
            });
        }
    };
    var highlightAll = function (containerEle) {
        var charIndexes = characterIndexesRef.current;
        if (charIndexes.length === 0) {
            return;
        }
        var spans = [].slice.call(containerEle.querySelectorAll('.rpv-core__text-layer-text'));
        var fullText = charIndexes.map(function (item) { return item.char; }).join('');
        keywordRegexp.forEach(function (keyword) {
            var keywordStr = keyword.source;
            if (!keywordStr.trim()) {
                return;
            }
            var cloneKeyword = keyword.flags.indexOf('g') === -1 ? new RegExp(keyword, keyword.flags + "g") : keyword;
            var match;
            var matches = [];
            while ((match = cloneKeyword.exec(fullText)) !== null) {
                matches.push({
                    keyword: cloneKeyword,
                    startIndex: match.index,
                    endIndex: cloneKeyword.lastIndex,
                });
            }
            matches
                .map(function (item) { return ({
                keyword: item.keyword,
                indexes: charIndexes.slice(item.startIndex, item.endIndex),
            }); })
                .forEach(function (item) {
                var spanIndexes = item.indexes.reduce(function (acc, item) {
                    acc[item.spanIndex] = __spreadArray(__spreadArray([], (acc[item.spanIndex] || [])), [item]);
                    return acc;
                }, {});
                Object.values(spanIndexes).forEach(function (charIndexSpan) {
                    highlight(item.keyword, containerEle, spans[charIndexSpan[0].spanIndex], charIndexSpan);
                });
            });
        });
    };
    var handleKeywordChanged = function (keyword) {
        if (keyword && keyword.length > 0) {
            setKeywordRegexp(keyword);
        }
    };
    var handleMatchChanged = function (currentMatch) {
        setMatch(currentMatch);
    };
    var handleRenderStatusChanged = function (status) {
        if (!status.has(pageIndex)) {
            return;
        }
        var currentStatus = status.get(pageIndex);
        if (currentStatus) {
            setRenderStatus({
                ele: currentStatus.ele,
                pageIndex: pageIndex,
                scale: currentStatus.scale,
                status: currentStatus.status,
            });
        }
    };
    var isEmptyKeyword = function () {
        return keywordRegexp.length === 0 || (keywordRegexp.length === 1 && keywordRegexp[0].source.trim() === '');
    };
    React__namespace.useEffect(function () {
        if (isEmptyKeyword() ||
            renderStatus.status !== core.LayerRenderStatus.DidRender ||
            characterIndexesRef.current.length) {
            return;
        }
        var containerEle = renderStatus.ele;
        var spans = [].slice.call(containerEle.querySelectorAll('.rpv-core__text-layer-text'));
        var charIndexes = spans
            .map(function (span) { return span.textContent; })
            .reduce(function (prev, curr, index) {
            return prev.concat(curr.split('').map(function (c, i) { return ({
                char: c,
                charIndexInSpan: i,
                spanIndex: index,
            }); }));
        }, [
            {
                char: '',
                charIndexInSpan: 0,
                spanIndex: 0,
            },
        ])
            .slice(1);
        characterIndexesRef.current = charIndexes;
    }, [keywordRegexp, renderStatus.status]);
    React__namespace.useEffect(function () {
        if (isEmptyKeyword() || !renderStatus.ele || renderStatus.status !== core.LayerRenderStatus.DidRender) {
            return;
        }
        var containerEle = renderStatus.ele;
        unhighlightAll(containerEle);
        highlightAll(containerEle);
        scrollToMatch();
    }, [keywordRegexp, match, renderStatus.status, characterIndexesRef.current]);
    React__namespace.useEffect(function () {
        if (isEmptyKeyword() && renderStatus.ele && renderStatus.status === core.LayerRenderStatus.DidRender) {
            unhighlightAll(renderStatus.ele);
        }
    }, [keywordRegexp, renderStatus.status]);
    var scrollToMatch = function () {
        if (match.pageIndex !== pageIndex || !renderStatus.ele || renderStatus.status !== core.LayerRenderStatus.DidRender) {
            return;
        }
        var container = renderStatus.ele;
        var spans = container.querySelectorAll('.rpv-search__highlight');
        if (match.matchIndex < spans.length) {
            var span = spans[match.matchIndex];
            var _a = calculateOffset(span, container), left = _a.left, top_1 = _a.top;
            var jump = store.get('jumpToDestination');
            if (jump) {
                jump(pageIndex, (container.getBoundingClientRect().height - top_1) / renderStatus.scale, left / renderStatus.scale, renderStatus.scale);
                if (currentMatchRef.current) {
                    currentMatchRef.current.classList.remove('rpv-search__highlight--current');
                }
                currentMatchRef.current = span;
                span.classList.add('rpv-search__highlight--current');
            }
        }
    };
    React__namespace.useEffect(function () {
        store.subscribe('keyword', handleKeywordChanged);
        store.subscribe('match', handleMatchChanged);
        store.subscribe('renderStatus', handleRenderStatusChanged);
        return function () {
            store.unsubscribe('keyword', handleKeywordChanged);
            store.unsubscribe('match', handleMatchChanged);
            store.unsubscribe('renderStatus', handleRenderStatusChanged);
        };
    }, []);
    return React__namespace.createElement(React__namespace.Fragment, null);
};

var searchPlugin = function (props) {
    var onHighlightKeyword = React__namespace.useMemo(function () { return (props && props.onHighlightKeyword ? props.onHighlightKeyword : function () { }); }, []);
    var store = React__namespace.useMemo(function () {
        return core.createStore({
            renderStatus: new Map(),
        });
    }, []);
    var _a = useSearch(store), clearKeyword = _a.clearKeyword, jumpToNextMatch = _a.jumpToNextMatch, jumpToPreviousMatch = _a.jumpToPreviousMatch, searchFor = _a.searchFor, setKeywords = _a.setKeywords;
    var SearchDecorator = function (props) { return React__namespace.createElement(Search, __assign({}, props, { store: store })); };
    var ShowSearchPopoverDecorator = function (props) { return (React__namespace.createElement(ShowSearchPopover, __assign({}, props, { store: store }))); };
    var ShowSearchPopoverButtonDecorator = function () { return (React__namespace.createElement(ShowSearchPopoverDecorator, null, function (props) { return React__namespace.createElement(ShowSearchPopoverButton, __assign({}, props)); })); };
    var renderViewer = function (renderViewerProps) {
        var currentSlot = renderViewerProps.slot;
        if (currentSlot.subSlot) {
            currentSlot.subSlot.children = (React__namespace.createElement(React__namespace.Fragment, null,
                Array(renderViewerProps.doc.numPages)
                    .fill(0)
                    .map(function (_, index) { return (React__namespace.createElement(Tracker, { key: index, pageIndex: index, store: store, onHighlightKeyword: onHighlightKeyword })); }),
                currentSlot.subSlot.children));
        }
        return currentSlot;
    };
    var normalizeKeywords = function (keyword) {
        return Array.isArray(keyword) ? keyword.map(function (k) { return normalizeSingleKeyword(k); }) : [normalizeSingleKeyword(keyword)];
    };
    return {
        install: function (pluginFunctions) {
            var keyword = props && props.keyword ? normalizeKeywords(props.keyword) : [EMPTY_KEYWORD_REGEXP];
            store.update('jumpToDestination', pluginFunctions.jumpToDestination);
            store.update('jumpToPage', pluginFunctions.jumpToPage);
            store.update('keyword', keyword);
        },
        renderViewer: renderViewer,
        uninstall: function (props) {
            var renderStatus = store.get('renderStatus');
            if (renderStatus) {
                renderStatus.clear();
            }
        },
        onDocumentLoad: function (props) {
            store.update('doc', props.doc);
        },
        onTextLayerRender: function (props) {
            var renderStatus = store.get('renderStatus');
            if (renderStatus) {
                renderStatus = renderStatus.set(props.pageIndex, props);
                store.update('renderStatus', renderStatus);
            }
        },
        Search: SearchDecorator,
        ShowSearchPopover: ShowSearchPopoverDecorator,
        ShowSearchPopoverButton: ShowSearchPopoverButtonDecorator,
        clearHighlights: function () {
            clearKeyword();
        },
        highlight: function (keyword) {
            var keywords = Array.isArray(keyword) ? keyword : [keyword];
            setKeywords(keywords);
            searchFor(keywords);
        },
        jumpToNextMatch: jumpToNextMatch,
        jumpToPreviousMatch: jumpToPreviousMatch,
    };
};

exports.NextIcon = NextIcon;
exports.PreviousIcon = PreviousIcon;
exports.SearchIcon = SearchIcon;
exports.searchPlugin = searchPlugin;
